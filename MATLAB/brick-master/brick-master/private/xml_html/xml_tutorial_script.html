
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>Tutorial for xml_io_tools Package</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2007-07-18">
      <meta name="m-file" content="xml_tutorial_script"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>Tutorial for xml_io_tools Package</h1>
         <introduction>
            <p><b>By Jarek Tuszynski</b> Package xml_io_tools can read XML files into MATLAB struct and writes MATLAB data types to XML files with help of simple
               interface to MATLAB's xmlwrite and xmlread functions.
            </p>
            <p>Two function to simplify reading and writing XML files from MATLAB:</p>
            <div>
               <ul>
                  <li>Function xml_read first calls MATLAB's xmlread function and than converts its output ('Document Object Model' tree of Java
                     objects) to tree of MATLAB struct's. The output is in the format of nested structs and cells. In the output data structure
                     field names are based on XML tags.
                  </li>
               </ul>
            </div>
            <div>
               <ul>
                  <li>Function xml_write first convert input tree of MATLAB structs and cells and other types to tree of 'Document Object Model'
                     nodes, and then writes resulting object to XML file using MATLAB's xmlwrite function. .
                  </li>
               </ul>
            </div>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">This package can:</a></li>
               <li><a href="#2">This package can't:</a></li>
               <li><a href="#3">Change History:</a></li>
               <li><a href="#4">Licence</a></li>
               <li><a href="#5">Save data structure using xml_write</a></li>
               <li><a href="#6">Using "Pref.XmlEngine" flag in xml_write</a></li>
               <li><a href="#7">Read XML file using xml_read</a></li>
               <li><a href="#8">Using "Pref.StructItem" flag in xml_write</a></li>
               <li><a href="#12">Using "Pref.CellItem" flag in xml_write</a></li>
               <li><a href="#16">Using "Pref.NoCells" flag in xml_read</a></li>
               <li><a href="#20">Using "Pref.ItemName" flag in xml_write and xml_read</a></li>
               <li><a href="#24">Write XML files with ATTRIBUTEs</a></li>
               <li><a href="#26">Write XML files with COMMENTs</a></li>
               <li><a href="#32">Write XML files with PROCESSING_INSTRUCTIONs</a></li>
               <li><a href="#38">Write XML files with CDATA Sections</a></li>
               <li><a href="#40">Write XML files with special characters in TAG names</a></li>
               <li><a href="#44">Write XML files with Namespaces</a></li>
               <li><a href="#48">Read xml file with all special node types</a></li>
               <li><a href="#51">Using "Pref.ReadAttr" and "Pref.ReadSpec" flags in xml_read</a></li>
               <li><a href="#52">Working with DOM objects</a></li>
               <li><a href="#55">Using xmlwrite_xerces function</a></li>
            </ul>
         </div>
         <h2>This package can:<a name="1"></a></h2>
         <div>
            <ul>
               <li>Read most XML files, created inside and outside of MATLAB, and   convert them to MATLAB data structures.</li>
               <li>Write any MATLAB's struct tree to XML file</li>
               <li>Handle XML attributes in the same way as xml_toolbox package</li>
               <li>Handle special XML nodes like comments, processing instructions and   CDATA sections</li>
               <li>Be studied, modified, customized, rewritten and used in other packages   without any limitations. All code is included and
                  documented. Software   is distributed under MIT Licence (included).
               </li>
            </ul>
         </div>
         <h2>This package can't:<a name="2"></a></h2>
         <div>
            <ul>
               <li>Guarantee to recover the same Matlab objects that were saved. If you need to be able to recover carbon copy of the structure
                  that was saved than you will have to use one of the packages that uses special set of tags saved as xml attributes that help
                  to guide the parsing of XML code. This package does not do that.
               </li>
               <li>Guarantee to work with MATLAB versions older than the package (2006/11). The code was never tested with older versions of
                  MATLAB.
               </li>
            </ul>
         </div>
         <h2>Change History:<a name="3"></a></h2>
         <div>
            <ul>
               <li>2006-11-06 - original version</li>
               <li>2006-11-26 - corrected xml_write to handle writing Matlab's column   arrays to xml files. Bug discovered and diagnosed by
                  Kalyan Dutta.
               </li>
               <li>2006-11-28 - made changes to handle special node types like:   COMMENTS and CDATA sections</li>
               <li>2007-02-20 - Writing CDATA sections still did not worked. The problem   was diagnosed and fixed by Alberto Amaro. The fix
                  involved rewriting   xmlwrite to use Apache Xerces java files directly instead of MATLAB's   XMLUtils java class.
               </li>
               <li>2007-06-20 - Fixed problem reported by Anna Kelbert in Reviews about   not writing attributes of ROOT node. Also: added support
                  for Processing   Instructions, added support for global text nodes: Processing   Instructions and comments, allowed writing
                  tag names with special   characters
               </li>
               <li>2007-07   - Added tutorial script file. Extended support for global   text nodes. Added more Preference fields.</li>
            </ul>
         </div>
         <h2>Licence<a name="4"></a></h2>
         <p>The package is distributed under MIT Licence</p><pre class="codeinput">format <span class="string">compact</span>; <span class="comment">% viewing preference</span>
clear <span class="string">all</span>;
type(<span class="string">'MIT_Licence.txt'</span>)
</pre><pre class="codeoutput">
Copyright (c) 2007 Jarek Tuszynski

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
</pre><h2>Save data structure using xml_write<a name="5"></a></h2>
         <p>Any MATLAB data struct can be saved to XML file. Notice that 'tree' only defines content of the root element. Its name has
            to be either passed separately or deduced from the input variable name.
         </p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><h2>Using "Pref.XmlEngine" flag in xml_write<a name="6"></a></h2>
         <p>Same operation using Apache Xerces XML engine. Notice that in this case root element name was passed as variable and not extracted
            from the variable name.
         </p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'TreeOfMine'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;TreeOfMine&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/TreeOfMine&gt;

</pre><h2>Read XML file using xml_read<a name="7"></a></h2><pre class="codeinput">[tree treeName] = xml_read (<span class="string">'test.xml'</span>);
disp([treeName <span class="string">' ='</span>])
gen_object_display(tree)
</pre><pre class="codeoutput">TreeOfMine =
    MyNumber: [13]
    MyString: 'Hello World'
</pre><h2>Using "Pref.StructItem" flag in xml_write<a name="8"></a></h2>
         <p><b>Create a simple structure with arrays of struct's</b></p><pre class="codeinput">MyTree = [];
MyTree.a(1).b = <span class="string">'jack'</span>;
MyTree.a(2).b = <span class="string">'john'</span>;
gen_object_display(MyTree)
</pre><pre class="codeoutput">    a: [1x2 struct]
       b: 'jack'

       b: 'john'

</pre><p><b>Write XML with "StructItem = true" (default).  Notice single 'a' section and multiple 'item' sub-sections. Those subsections
               are used to store array elements</b></p><pre class="codeinput">wPref.StructItem = true;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,wPref);
type(<span class="string">'test.xml'</span>)
disp(<span class="string">'\nxml_read output:\n'</span>)
gen_object_display(xml_read (<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;item&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/item&gt;
      &lt;item&gt;
         &lt;b&gt;john&lt;/b&gt;
      &lt;/item&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;
\nxml_read output:\n
    a: [1x2 struct]
       b: 'jack'

       b: 'john'

</pre><p><b>Write XML with "StructItem = false". Notice multiple 'a' sections</b></p><pre class="codeinput">wPref.StructItem = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,wPref);
type(<span class="string">'test.xml'</span>)
disp(<span class="string">'\nxml_read output:\n'</span>)
gen_object_display(xml_read (<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;b&gt;jack&lt;/b&gt;
   &lt;/a&gt;
   &lt;a&gt;
      &lt;b&gt;john&lt;/b&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;
\nxml_read output:\n
    a: [1x2 struct]
       b: 'jack'

       b: 'john'

</pre><p><b>Notice that xml_read function produced the same struct when reading both files</b></p>
         <h2>Using "Pref.CellItem" flag in xml_write<a name="12"></a></h2>
         <p><b>Create a simple structure with cell arrays</b></p><pre class="codeinput">MyTree = [];
MyTree.a = {<span class="string">'jack'</span>, <span class="string">'john'</span>};
disp(MyTree)
</pre><pre class="codeoutput">    a: {'jack'  'john'}
</pre><p><b>Write XML with "StructItem = true" (default).  Notice single 'a' section and multiple 'item' sections</b></p><pre class="codeinput">Pref=[]; Pref.CellItem = true;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
fprintf(<span class="string">'\nxml_read output:\n'</span>);
disp(xml_read (<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;item&gt;jack&lt;/item&gt;
      &lt;item&gt;john&lt;/item&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;

xml_read output:
    a: {'jack'  'john'}
</pre><p><b>Write XML with "StructItem = false". Notice multiple 'a' sections</b></p><pre class="codeinput">Pref=[]; Pref.CellItem = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
fprintf(<span class="string">'\nxml_read output:\n'</span>);
disp(xml_read (<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;jack&lt;/a&gt;
   &lt;a&gt;john&lt;/a&gt;
&lt;/MyTree&gt;

xml_read output:
    a: {'jack'  'john'}
</pre><p><b>Notice that xml_read function produced the same struct when reading both files</b></p>
         <h2>Using "Pref.NoCells" flag in xml_read<a name="16"></a></h2>
         <p><b>Create a cell/struct mixture object</b></p><pre class="codeinput">MyTree = [];
MyTree.a{1}.b = <span class="string">'jack'</span>;
MyTree.a{2}.c = <span class="string">'john'</span>;
gen_object_display(MyTree);
</pre><pre class="codeoutput">    a: [1x2 cell] = 
       b: 'jack'
       c: 'john'
</pre><p><b>Save it to xml file</b></p><pre class="codeinput">Pref=[]; Pref.CellItem = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;b&gt;jack&lt;/b&gt;
   &lt;/a&gt;
   &lt;a&gt;
      &lt;c&gt;john&lt;/c&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;
</pre><p><b>Read above file with "Pref.NoCells=true" (default) - output is quite different then input</b></p><pre class="codeinput">Pref=[]; Pref.NoCells=true;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a: [2x1 struct]
       b: 'jack'
       c: [0x0 double]

       b: [0x0 double]
       c: 'john'

</pre><p><b>Read above file with "Pref.NoCells=false" - now input and output are the same</b></p><pre class="codeinput">Pref=[]; Pref.NoCells=false;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a: [1x2 cell] = 
       b: 'jack'
       c: 'john'
</pre><h2>Using "Pref.ItemName" flag in xml_write and xml_read<a name="20"></a></h2>
         <p><b>Create a cell/struct mixture object</b></p><pre class="codeinput">MyTree = [];
MyTree.a{1}.b = <span class="string">'jack'</span>;
MyTree.a{2}.c = <span class="string">'john'</span>;
gen_object_display(MyTree);
</pre><pre class="codeoutput">    a: [1x2 cell] = 
       b: 'jack'
       c: 'john'
</pre><p><b>Save it to xml file, using 'item' notation but with different name</b></p><pre class="codeinput">Pref=[];
Pref.CellItem = true;
Pref.ItemName = <span class="string">'MyItem'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;MyItem&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/MyItem&gt;
      &lt;MyItem&gt;
         &lt;c&gt;john&lt;/c&gt;
      &lt;/MyItem&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;
</pre><p><b>Read above file with default settings ("Pref.ItemName = 'item'")</b></p><pre class="codeinput">Pref=[]; Pref.NoCells  = false;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a: [1x1 struct]
       MyItem: [1x2 cell] = 
               b: 'jack'
               c: 'john'
</pre><p><b>Read above file with "Pref.ItemName = 'MyItem'" - now saved and read MATLAB structures are the same</b></p><pre class="codeinput">Pref=[];
Pref.ItemName = <span class="string">'MyItem'</span>;
Pref.NoCells  = false;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a: [1x2 cell] = 
       b: 'jack'
       c: 'john'
</pre><h2>Write XML files with ATTRIBUTEs<a name="24"></a></h2>
         <p>In order to add node attributes a special ATTRIBUTE and CONTENT fields are used.</p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
MyTree.MyString.ATTRIBUTE.Num = 2;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString Num="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString Num="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><h2>Write XML files with COMMENTs<a name="26"></a></h2>
         <p>Insertion of Comments is done with help of special COMMENT field. Note that MATLAB's xmlwrite is less readable due to lack
            of end-of-line characters around comment section.
         </p><pre class="codeinput">MyTree=[];
MyTree.COMMENT = <span class="string">'This is a comment'</span>;
MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;&lt;!--This is a comment--&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b> gives the same result
         </p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;
    &lt;!--This is a comment--&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><p><b>Comments in XML top level (method #1)</b> This method uses cell array
         </p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, {<span class="string">'MyTree'</span>, [], <span class="string">'This is a global comment'</span>});
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--This is a global comment--&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b> gives even nicer results.
         </p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, {<span class="string">'MyTree'</span>, [], <span class="string">'This is a global comment'</span>}, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--This is a global comment--&gt;
&lt;MyTree&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><p><b>Comments in XML top level (method #2)</b> This method adds an extra top layer to the struct 'tree' and sets "Pref.RootOnly = false", which informs the function about
            the extra layer. Notice that RootName is also saved as a part of the 'tree', and does not have to be passed in separately.
         </p><pre class="codeinput">MyTree=[];
MyTree.COMMENT = <span class="string">'This is a global comment'</span>;
MyTree.MyTest.MyNumber = 13;
MyTree.MyTest.MyString = <span class="string">'Hello World'</span>;
Pref=[]; Pref.RootOnly = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--This is a global comment--&gt;
&lt;MyTest&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTest&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[];
Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
Pref.RootOnly  = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--This is a global comment--&gt;
&lt;MyTest&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTest&gt;

</pre><h2>Write XML files with PROCESSING_INSTRUCTIONs<a name="32"></a></h2>
         <p>Insertion of Processing Instructions is done through use of special PROCESSING_INSTRUCTION field, which stores the instruction
            string. The string has to be in 'target data' format separated by space.
         </p><pre class="codeinput">MyTree=[];
MyTree.PROCESSING_INSTRUCTION = <span class="string">'xml-stylesheet type="a" href="foo"'</span>;
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;&lt;?xml-stylesheet type="a" href="foo"?&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;&lt;?xml-stylesheet type="a" href="foo"?&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><p><b>PROCESSING_INSTRUCTIONs in XML top level (method #1)</b> This method uses cell array
         </p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, {<span class="string">'MyTree'</span>, <span class="string">'xml-stylesheet type="a" href="foo"'</span>});
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;?xml-stylesheet type="a" href="foo"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, {<span class="string">'MyTree'</span>, <span class="string">'xml-stylesheet type="a" href="foo"'</span>}, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="a" href="foo"?&gt;
&lt;MyTree&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><p><b>PROCESSING_INSTRUCTIONs in XML top level (method #2)</b> This method adds an extra top layer to the struct 'tree' and sets pref.RootOnly=false, which informs the function about the
            extra layer. Notice that RootName is also saved as a part of the 'tree', and does not have to be passed in separately.
         </p><pre class="codeinput">MyTree=[];
MyTree.PROCESSING_INSTRUCTION =  <span class="string">'xml-stylesheet type="a" href="foo"'</span>;
MyTree.MyTest.MyNumber = 13;
MyTree.MyTest.MyString = <span class="string">'Hello World'</span>;
Pref=[]; Pref.RootOnly = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;?xml-stylesheet type="a" href="foo"?&gt;
&lt;MyTest&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTest&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[];
Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
Pref.RootOnly  = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="a" href="foo"?&gt;
&lt;MyTest&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTest&gt;

</pre><h2>Write XML files with CDATA Sections<a name="38"></a></h2>
         <p>"In an XML document a CDATA (Character DATA) section is a section of  element content that is marked for the parser to interpret
            as only  character data, not markup." (from Wikipedia) To insert CDATA Sections one use special CDATA_SECTION field,  which
            stores the instruction string. Note that MATLAB's xmlwrite created  wrong xml code for CDATA section
         </p><pre class="codeinput">MyTree=[];
MyTree.CDATA_SECTION = <span class="string">'&lt;A&gt;txt&lt;/A&gt;'</span>;
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;&amp;lt;A&amp;gt;txt&amp;lt;/A&amp;gt;&lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine produces correct results</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;&lt;![CDATA[&lt;A&gt;txt&lt;/A&gt;]]&gt;&lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><h2>Write XML files with special characters in TAG names<a name="40"></a></h2>
         <p>The input to xml_write requires that all tags one wants in XML document have to be encoded as field names of MATLAB's struct's.
            Matlab has a lot of restrictions on variable names. This section is about XML tags with names not allowed as MATLAB variables,
            or more specifically with characters allowed as xml tag names but not allowed as MATLAB variable names. Characters like that
            can be replaced by their hexadecimal representation just as it is done by genvarname function. Alternative way of writing
            the first example is:
         </p><pre class="codeinput">MyTree=[];
MyTree.(<span class="string">'MyNumber'</span>) = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
MyTree.MyString.ATTRIBUTE.(<span class="string">'Num'</span>) = 2;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString Num="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>This approach fails for some characters like dash '-', colon ':', and international characters.</b></p><pre class="codeinput">MyTree=[];
<span class="keyword">try</span>
  MyTree.(<span class="string">'My-Number'</span>) = 13;
  MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
  MyTree.MyString.ATTRIBUTE.(<span class="string">'Num_&ouml;'</span>) = 2;
<span class="keyword">catch</span>
  err = lasterror;
  disp(err.message);
<span class="keyword">end</span>
</pre><pre class="codeoutput">Error using ==&gt; evalin
Invalid field name: 'My-Number'.
</pre><p>It can be overcome by replacing offending characters with their hexadecimal representation. That can be done manually or with
            use of genvarname function. Note that MATLAB 'type' function does not show correctly '&ouml;' letter in xml file, but opening the
            file in editor shows that it is correct.
         </p><pre class="codeinput">MyTree=[];
MyTree.(genvarname(<span class="string">'My-Number'</span>)) = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
MyTree.MyString.ATTRIBUTE.Num_0xF6 = 2;
gen_object_display(MyTree);
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">    My0x2DNumber: [13]
        MyString: [1x1 struct]
                    CONTENT: 'Hello World'
                  ATTRIBUTE: [1x1 struct]
                             Num_0xF6: [2]

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;My-Number&gt;13&lt;/My-Number&gt;
   &lt;MyString Num_&Atilde;&para;="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Also two of the characters '-' and ':' can be encoded by a special strings: '_DASH_' and '_COLON_' respectively</b></p><pre class="codeinput">MyTree=[];
MyTree.My_DASH_Number = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
MyTree.MyString.ATTRIBUTE.Num0xF6 = 2;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;My-Number&gt;13&lt;/My-Number&gt;
   &lt;MyString Num&Atilde;&para;="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><h2>Write XML files with Namespaces<a name="44"></a></h2>
         <p>No extra special fields are needed to define XML namespaces, only colon character written using '0x3A' or '_COLON_'. Below
            is an example of a namespace definition
         </p><pre class="codeinput">MyTree=[];
MyTree.f_COLON_child.ATTRIBUTE.xmlns_COLON_f = <span class="string">'http://www.foo.com'</span>;
MyTree.f_COLON_child.f_COLON_MyNumber = 13;
MyTree.f_COLON_child.f_COLON_MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;f:child xmlns:f="http://www.foo.com"&gt;
      &lt;f:MyNumber&gt;13&lt;/f:MyNumber&gt;
      &lt;f:MyString&gt;Hello World&lt;/f:MyString&gt;
   &lt;/f:child&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'f_COLON_MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;
    &lt;f:child xmlns:f="http://www.foo.com"&gt;
        &lt;f:MyNumber&gt;13&lt;/f:MyNumber&gt;
        &lt;f:MyString&gt;Hello World&lt;/f:MyString&gt;
    &lt;/f:child&gt;
&lt;/f:MyTree&gt;

</pre><p><b>Another example of namespaces which is handled differently by both xml writing methods. Either I have created illegal configuration
               or both methods have bugs.</b></p><pre class="codeinput">MyTree=[];
MyTree.ATTRIBUTE.xmlns_COLON_f = <span class="string">'http://www.foo.com'</span>;
MyTree.f_COLON_MyNumber = 13;
MyTree.f_COLON_MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'f_COLON_MyTree'</span>);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;f:MyTree xmlns:f=""&gt;
   &lt;f:MyNumber&gt;13&lt;/f:MyNumber&gt;
   &lt;f:MyString&gt;Hello World&lt;/f:MyString&gt;
&lt;/f:MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'f_COLON_MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree xmlns:f="http://www.foo.com"&gt;
    &lt;f:MyNumber&gt;13&lt;/f:MyNumber&gt;
    &lt;f:MyString&gt;Hello World&lt;/f:MyString&gt;
&lt;/f:MyTree&gt;

</pre><h2>Read xml file with all special node types<a name="48"></a></h2>
         <p>Display and read the file, then show the data structure. Note that MATLAB 'type' function does not show correctly '&ouml;' letter
            in xml file, but opening the file in editor shows that it is correct.
         </p><pre class="codeinput">fprintf(<span class="string">'Test xml file:\n'</span>);
type(<span class="string">'test_file.xml'</span>)
</pre><pre class="codeoutput">Test xml file:

&lt;?xml version="1.0" encoding="utf-8" ?&gt; 
&lt;?xml-stylesheet type="text/css" href="foo.css"?&gt;
&lt;!-- This is a Global Comment --&gt;
&lt;aaa xmlns:xsi="http://www.foo.org"&gt;
  &lt;?ProcInst type="local processing instruction"?&gt;
  &lt;!-- local comment 1 --&gt;
  bbb
  &lt;!-- local comment 2 --&gt;
  ccc
  &lt;matrix bad-name='fff'&gt;
    5e3+2*i, Inf
    NaN,     pi
  &lt;/matrix&gt;
  &lt;ee_e&gt; ee_e &lt;/ee_e&gt;
  &lt;ff-f&gt; ff-f &lt;/ff-f&gt;
  &lt;gg&Atilde;&para;g&gt; gg&Atilde;&para;g &lt;/gg&Atilde;&para;g&gt;
  &lt;![CDATA[
    Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text
	]]&gt;
&lt;/aaa&gt;


</pre><p>Read only the Root Element (default)</p><pre class="codeinput">[tree GlobalTextNodes] = xml_read(<span class="string">'test_file.xml'</span>);
fprintf(<span class="string">'Global Data (Root name, Global Processing Instructions and Global Comments):\n'</span>);
disp(GlobalTextNodes')
fprintf(<span class="string">'\nStructure read from the file (uncludes COMMENT and CDATA sections):\n'</span>);
gen_object_display(tree);
</pre><pre class="codeoutput">Global Data (Root name, Global Processing Instructions and Global Comments):
    'aaa'
    'xml-stylesheet type="text/css" href="foo.css"'
    'This is a Global Comment'

Structure read from the file (uncludes COMMENT and CDATA sections):
    PROCESSING_INSTRUCTION: 'ProcInst type="local processing instruction"'
                   COMMENT: [1x2 cell] = 
                            local comment 1
                            local comment 2
                   CONTENT: [1x2 cell] = 
                            bbb
                            ccc
                    matrix: [1x1 struct]
                              CONTENT: [2x2 double]
                            ATTRIBUTE: [1x1 struct]
                                       bad_DASH_name: 'fff'
                      ee_e: 'ee_e'
                 ff_DASH_f: 'ff-f'
                   gg0xF6g: 'gg&ouml;g'
             CDATA_SECTION: 'Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text'
                 ATTRIBUTE: [1x1 struct]
                            xmlns_COLON_xsi: 'http://www.foo.org'
</pre><p>Read the whole tree including global Comments and Processing Instructions</p><pre class="codeinput">Pref=[]; Pref.RootOnly = false;
[tree GlobalTextNodes] = xml_read(<span class="string">'test_file.xml'</span>, Pref);
fprintf(<span class="string">'Global Data (Root name, Global Processing Instructions and Global Comments):\n'</span>);
disp(GlobalTextNodes')
fprintf(<span class="string">'\nStructure read from the file (uncludes COMMENT and CDATA sections):\n'</span>);
gen_object_display(tree);
</pre><pre class="codeoutput">Global Data (Root name, Global Processing Instructions and Global Comments):
    'aaa'
    'xml-stylesheet type="text/css" href="foo.css"'
    'This is a Global Comment'

Structure read from the file (uncludes COMMENT and CDATA sections):
    PROCESSING_INSTRUCTION: 'xml-stylesheet type="text/css" href="foo.css"'
                   COMMENT: 'This is a Global Comment'
                       aaa: [1x1 struct]
                            PROCESSING_INSTRUCTION: 'ProcInst type="local processing instruction"'
                                           COMMENT: [1x2 cell] = 
                                                    local comment 1
                                                    local comment 2
                                           CONTENT: [1x2 cell] = 
                                                    bbb
                                                    ccc
                                            matrix: [1x1 struct]
                                                      CONTENT: [2x2 double]
                                                    ATTRIBUTE: [1x1 struct]
                                                               bad_DASH_name: 'fff'
                                              ee_e: 'ee_e'
                                         ff_DASH_f: 'ff-f'
                                           gg0xF6g: 'gg&ouml;g'
                                     CDATA_SECTION: 'Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text'
                                         ATTRIBUTE: [1x1 struct]
                                                    xmlns_COLON_xsi: 'http://www.foo.org'
</pre><h2>Using "Pref.ReadAttr" and "Pref.ReadSpec" flags in xml_read<a name="51"></a></h2>
         <p>Those option allow exclusion of attributes or special nodes, like comments, processing instructions, CData sections, etc.</p><pre class="codeinput">Pref=[];
Pref.ReadAttr = false; <span class="comment">% do not read attributes</span>
Pref.ReadSpec = false; <span class="comment">% do not read special node types</span>
tree = xml_read(<span class="string">'test_file.xml'</span>, Pref);
gen_object_display(tree);
</pre><pre class="codeoutput">      CONTENT: [1x2 cell] = 
               bbb
               ccc
       matrix: [2x2 double]
         ee_e: 'ee_e'
    ff_DASH_f: 'ff-f'
      gg0xF6g: 'gg&ouml;g'
</pre><h2>Working with DOM objects<a name="52"></a></h2>
         <p><b>Create Struct tree</b></p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
</pre><p><b>Convert Struct to DOM object using xml_write</b></p><pre class="codeinput">DOM = xml_write([], MyTree);
xmlwrite(<span class="string">'test.xml'</span>, DOM);   <span class="comment">% Save DOM object using MATLAB function</span>
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Convert DOM object to Struct using xml_read</b></p><pre class="codeinput">DOM = xmlread(<span class="string">'test.xml'</span>);       <span class="comment">% Read DOM object using MATLAB function</span>
[tree treeName] = xml_read(DOM); <span class="comment">% Convert DOM object to Struct</span>
disp([treeName <span class="string">' ='</span>])
gen_object_display(tree)
</pre><pre class="codeoutput">MyTree =
    MyNumber: [13]
    MyString: 'Hello World'
</pre><h2>Using xmlwrite_xerces function<a name="55"></a></h2><pre class="codeinput">xmlwrite_xerces(<span class="string">'test.xml'</span>, MyTree); <span class="comment">% Save DOM object using Xerces library</span>
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">No constructor org.apache.xml.serialize.OutputFormat with matching signature found</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Tutorial for xml_io_tools Package
% *By Jarek Tuszynski*
% Package xml_io_tools can read XML files into MATLAB struct and writes 
% MATLAB data types to XML files with help of simple interface to 
% MATLAB's xmlwrite and xmlread functions.
% 
% Two function to simplify reading and writing XML files from MATLAB:
%
% * Function xml_read first calls MATLAB's xmlread function and than 
% converts its output ('Document Object Model' tree of Java objects) 
% to tree of MATLAB struct's. The output is in the format of nested 
% structs and cells. In the output data structure field names are based on
% XML tags.
%
% * Function xml_write first convert input tree of MATLAB structs and cells 
% and other types to tree of 'Document Object Model' nodes, and then writes 
% resulting object to XML file using MATLAB's xmlwrite function. .
%
%% This package can:
% * Read most XML files, created inside and outside of MATLAB, and 
%   convert them to MATLAB data structures.
% * Write any MATLAB's struct tree to XML file
% * Handle XML attributes in the same way as xml_toolbox package
% * Handle special XML nodes like comments, processing instructions and 
%   CDATA sections
% * Be studied, modified, customized, rewritten and used in other packages 
%   without any limitations. All code is included and documented. Software
%   is distributed under MIT Licence (included).   
%
%% This package can't:
% * Guarantee to recover the same Matlab objects that were saved. If you 
% need to be able to recover carbon copy of the structure that was saved 
% than you will have to use one of the packages that uses special set of 
% tags saved as xml attributes that help to guide the parsing of XML code. 
% This package does not do that.
% * Guarantee to work with MATLAB versions older than the package (2006/11).
% The code was never tested with older versions of MATLAB.
%
%% Change History:
% * 2006-11-06 - original version
% * 2006-11-26 - corrected xml_write to handle writing Matlab's column
%   arrays to xml files. Bug discovered and diagnosed by Kalyan Dutta.
% * 2006-11-28 - made changes to handle special node types like: 
%   COMMENTS and CDATA sections 
% * 2007-02-20 - Writing CDATA sections still did not worked. The problem 
%   was diagnosed and fixed by Alberto Amaro. The fix involved rewriting
%   xmlwrite to use Apache Xerces java files directly instead of MATLAB's 
%   XMLUtils java class.
% * 2007-06-20 - Fixed problem reported by Anna Kelbert in Reviews about 
%   not writing attributes of ROOT node. Also: added support for Processing
%   Instructions, added support for global text nodes: Processing
%   Instructions and comments, allowed writing tag names with special
%   characters
% * 2007-07   - Added tutorial script file. Extended support for global
%   text nodes. Added more Preference fields.
%% Licence
% The package is distributed under MIT Licence
format compact; % viewing preference
clear all;
type('MIT_Licence.txt')

%% Save data structure using xml_write
% Any MATLAB data struct can be saved to XML file. Notice that
% 'tree' only defines content of the root element. Its name has to be
% either passed separately or deduced from the input variable name.
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree);
type('test.xml')

%% Using "Pref.XmlEngine" flag in xml_write
% Same operation using Apache Xerces XML engine. Notice that in this case root element name
% was passed as variable and not extracted from the variable name.
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'TreeOfMine', Pref);
type('test.xml')


%% Read XML file using xml_read
[tree treeName] = xml_read ('test.xml');
disp([treeName ' ='])
gen_object_display(tree)

%% Using "Pref.StructItem" flag in xml_write
% *Create a simple structure with arrays of struct's*
MyTree = [];
MyTree.a(1).b = 'jack';
MyTree.a(2).b = 'john';
gen_object_display(MyTree)
%%
% *Write XML with "StructItem = true" (default).  Notice single 'a' 
% section and multiple 'item' sub-sections. Those subsections are used 
% to store array elements*
wPref.StructItem = true;
xml_write('test.xml', MyTree, 'MyTree',wPref);
type('test.xml')
disp('\nxml_read output:\n')
gen_object_display(xml_read ('test.xml'))
%%
% *Write XML with "StructItem = false". Notice multiple 'a' sections*
wPref.StructItem = false;
xml_write('test.xml', MyTree, 'MyTree',wPref);
type('test.xml')
disp('\nxml_read output:\n')
gen_object_display(xml_read ('test.xml'))
%%
% *Notice that xml_read function produced the same struct when reading both files*

%% Using "Pref.CellItem" flag in xml_write
% *Create a simple structure with cell arrays*
MyTree = [];
MyTree.a = {'jack', 'john'};
disp(MyTree)
%%
% *Write XML with "StructItem = true" (default).  Notice single 'a' 
% section and multiple 'item' sections*
Pref=[]; Pref.CellItem = true;
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')
fprintf('\nxml_read output:\n');
disp(xml_read ('test.xml'))
%%
% *Write XML with "StructItem = false". Notice multiple 'a' sections*
Pref=[]; Pref.CellItem = false;
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')
fprintf('\nxml_read output:\n');
disp(xml_read ('test.xml'))
%%
% *Notice that xml_read function produced the same struct when reading both files*


%% Using "Pref.NoCells" flag in xml_read
% *Create a cell/struct mixture object*
MyTree = [];
MyTree.a{1}.b = 'jack';
MyTree.a{2}.c = 'john';
gen_object_display(MyTree);
%%
% *Save it to xml file*
Pref=[]; Pref.CellItem = false;
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')
%%
% *Read above file with "Pref.NoCells=true" (default) - output is quite different then input*
Pref=[]; Pref.NoCells=true;
gen_object_display(xml_read('test.xml', Pref))
%%
% *Read above file with "Pref.NoCells=false" - now input and output are the same*
Pref=[]; Pref.NoCells=false;
gen_object_display(xml_read('test.xml', Pref))

%% Using "Pref.ItemName" flag in xml_write and xml_read
% *Create a cell/struct mixture object*
MyTree = [];
MyTree.a{1}.b = 'jack';
MyTree.a{2}.c = 'john';
gen_object_display(MyTree);
%%
% *Save it to xml file, using 'item' notation but with different name*
Pref=[]; 
Pref.CellItem = true;
Pref.ItemName = 'MyItem';
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')
%%
% *Read above file with default settings ("Pref.ItemName = 'item'")*
Pref=[]; Pref.NoCells  = false;
gen_object_display(xml_read('test.xml', Pref))
%%
% *Read above file with "Pref.ItemName = 'MyItem'" - now saved and read 
% MATLAB structures are the same*
Pref=[]; 
Pref.ItemName = 'MyItem';
Pref.NoCells  = false;
gen_object_display(xml_read('test.xml', Pref))


%% Write XML files with ATTRIBUTEs 
% In order to add node attributes a special ATTRIBUTE and CONTENT fields 
% are used.
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = 'Hello World';
MyTree.MyString.ATTRIBUTE.Num = 2;
xml_write('test.xml', MyTree);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')

%% Write XML files with COMMENTs
% Insertion of Comments is done with help of special COMMENT field.
% Note that MATLAB's xmlwrite is less readable due to lack of end-of-line 
% characters around comment section. 
MyTree=[];
MyTree.COMMENT = 'This is a comment';
MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = 'Hello World';
xml_write('test.xml', MyTree);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
% gives the same result
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'MyTree', Pref);
type('test.xml')

%%
% *Comments in XML top level (method #1)*
% This method uses cell array 
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree, {'MyTree', [], 'This is a global comment'});
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine* 
% gives even nicer results.
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, {'MyTree', [], 'This is a global comment'}, Pref);
type('test.xml')

%%
% *Comments in XML top level (method #2)*
% This method adds an extra top layer to the struct 'tree' and sets
% "Pref.RootOnly = false", which informs the function about the extra 
% layer. Notice that RootName is also saved as a part of
% the 'tree', and does not have to be passed in separately.
MyTree=[];
MyTree.COMMENT = 'This is a global comment';
MyTree.MyTest.MyNumber = 13;
MyTree.MyTest.MyString = 'Hello World';
Pref=[]; Pref.RootOnly = false;
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; 
Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
Pref.RootOnly  = false;
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')

%% Write XML files with PROCESSING_INSTRUCTIONs 
% Insertion of Processing Instructions is done through use of special 
% PROCESSING_INSTRUCTION field, which stores the instruction string. The
% string has to be in 'target data' format separated by space.
MyTree=[];
MyTree.PROCESSING_INSTRUCTION = 'xml-stylesheet type="a" href="foo"';
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree);
type('test.xml')

%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'MyTree', Pref);
type('test.xml')

%%
% *PROCESSING_INSTRUCTIONs in XML top level (method #1)*
% This method uses cell array 
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree, {'MyTree', 'xml-stylesheet type="a" href="foo"'});
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, {'MyTree', 'xml-stylesheet type="a" href="foo"'}, Pref);
type('test.xml')

%%
% *PROCESSING_INSTRUCTIONs in XML top level (method #2)*
% This method adds an extra top layer to the struct 'tree' and sets
% pref.RootOnly=false, which informs the function about the extra 
% layer. Notice that RootName is also saved as a part of
% the 'tree', and does not have to be passed in separately.
MyTree=[];
MyTree.PROCESSING_INSTRUCTION =  'xml-stylesheet type="a" href="foo"';
MyTree.MyTest.MyNumber = 13;
MyTree.MyTest.MyString = 'Hello World';
Pref=[]; Pref.RootOnly = false;
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; 
Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
Pref.RootOnly  = false;
xml_write('test.xml', MyTree, 'MyTree', Pref);
type('test.xml')

%% Write XML files with CDATA Sections 
% "In an XML document a CDATA (Character DATA) section is a section of 
%  element content that is marked for the parser to interpret as only 
%  character data, not markup." (from Wikipedia) 
% To insert CDATA Sections one use special CDATA_SECTION field,
%  which stores the instruction string. Note that MATLAB's xmlwrite created
%  wrong xml code for CDATA section
MyTree=[];
MyTree.CDATA_SECTION = '<A>txt</A>';
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine produces correct results*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'MyTree', Pref);
type('test.xml')

%% Write XML files with special characters in TAG names
% The input to xml_write requires that all tags one wants in XML document 
% have to be encoded as field names of MATLAB's struct's. Matlab has a lot
% of restrictions on variable names. This section is about XML tags with
% names not allowed as MATLAB variables, or more specifically with
% characters allowed as xml tag names but not allowed as MATLAB variable
% names. Characters like that can be replaced by their hexadecimal
% representation just as it is done by genvarname function. Alternative way
% of writing the first example is:
MyTree=[];
MyTree.('MyNumber') = 13;
MyTree.MyString.CONTENT = 'Hello World';
MyTree.MyString.ATTRIBUTE.('Num') = 2;
xml_write('test.xml', MyTree);
type('test.xml')

%%
% *This approach fails for some characters like dash '-', colon ':', and
% international characters.*
MyTree=[];
try
  MyTree.('My-Number') = 13;
  MyTree.MyString.CONTENT = 'Hello World';
  MyTree.MyString.ATTRIBUTE.('Num_ö') = 2;
catch
  err = lasterror;
  disp(err.message);
end

%%
% It can be overcome by replacing offending characters with their 
% hexadecimal representation. That can be done manually or with use of 
% genvarname function. Note that MATLAB 'type' function does not show
% correctly 'ö' letter in xml file, but opening the file in editor shows 
% that it is correct.
MyTree=[];
MyTree.(genvarname('My-Number')) = 13;
MyTree.MyString.CONTENT = 'Hello World';
MyTree.MyString.ATTRIBUTE.Num_0xF6 = 2;
gen_object_display(MyTree);
xml_write('test.xml', MyTree);
type('test.xml')

%%
% *Also two of the characters '-' and ':' can be encoded by a special strings:
% '_DASH_' and '_COLON_' respectively*
MyTree=[];
MyTree.My_DASH_Number = 13;
MyTree.MyString.CONTENT = 'Hello World';
MyTree.MyString.ATTRIBUTE.Num0xF6 = 2;
xml_write('test.xml', MyTree);
type('test.xml')

%% Write XML files with Namespaces
% No extra special fields are needed to define XML namespaces, only colon 
% character written using '0x3A' or '_COLON_'. Below is an
% example of a namespace definition
MyTree=[];
MyTree.f_COLON_child.ATTRIBUTE.xmlns_COLON_f = 'http://www.foo.com';
MyTree.f_COLON_child.f_COLON_MyNumber = 13;
MyTree.f_COLON_child.f_COLON_MyString = 'Hello World';
xml_write('test.xml', MyTree, 'MyTree');
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'f_COLON_MyTree', Pref);
type('test.xml')

%% 
% *Another example of namespaces which is handled differently by both xml writing 
% methods. Either I have created illegal configuration or both methods have bugs.*  
MyTree=[];
MyTree.ATTRIBUTE.xmlns_COLON_f = 'http://www.foo.com';
MyTree.f_COLON_MyNumber = 13;
MyTree.f_COLON_MyString = 'Hello World';
xml_write('test.xml', MyTree, 'f_COLON_MyTree');
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'f_COLON_MyTree', Pref);
type('test.xml')


%% Read xml file with all special node types
% Display and read the file, then show the data structure. Note that 
% MATLAB 'type' function does not show correctly 'ö' letter in xml file, 
% but opening the file in editor shows that it is correct.
fprintf('Test xml file:\n');
type('test_file.xml')
%%
% Read only the Root Element (default) 
[tree GlobalTextNodes] = xml_read('test_file.xml');
fprintf('Global Data (Root name, Global Processing Instructions and Global Comments):\n');
disp(GlobalTextNodes')
fprintf('\nStructure read from the file (uncludes COMMENT and CDATA sections):\n');
gen_object_display(tree);
%%
% Read the whole tree including global Comments and Processing Instructions
Pref=[]; Pref.RootOnly = false;
[tree GlobalTextNodes] = xml_read('test_file.xml', Pref);
fprintf('Global Data (Root name, Global Processing Instructions and Global Comments):\n');
disp(GlobalTextNodes')
fprintf('\nStructure read from the file (uncludes COMMENT and CDATA sections):\n');
gen_object_display(tree);

%% Using "Pref.ReadAttr" and "Pref.ReadSpec" flags in xml_read
% Those option allow exclusion of attributes or special nodes, like
% comments, processing instructions, CData sections, etc.
Pref=[]; 
Pref.ReadAttr = false; % do not read attributes
Pref.ReadSpec = false; % do not read special node types
tree = xml_read('test_file.xml', Pref);
gen_object_display(tree);

%% Working with DOM objects
% *Create Struct tree*
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
%%
% *Convert Struct to DOM object using xml_write*
DOM = xml_write([], MyTree); 
xmlwrite('test.xml', DOM);   % Save DOM object using MATLAB function 
type('test.xml')
%% 
% *Convert DOM object to Struct using xml_read*
DOM = xmlread('test.xml');       % Read DOM object using MATLAB function
[tree treeName] = xml_read(DOM); % Convert DOM object to Struct
disp([treeName ' ='])
gen_object_display(tree)

%% Using xmlwrite_xerces function
xmlwrite_xerces('test.xml', MyTree); % Save DOM object using Xerces library 
type('test.xml')

##### SOURCE END #####
-->
   </body>
</html>